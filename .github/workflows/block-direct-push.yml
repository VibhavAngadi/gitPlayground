name: block-direct-push
on:
  push:
    branches:
      - main

concurrency:
  group: block-direct-push-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  # Note: writing workflow files may require a PAT with workflow scope (see notes below).

env:
  REPO: ${{ github.repository }}
  GITHUB_API: https://api.github.com

jobs:
  detect-and-revert:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.set_outputs.outputs.should_run }}
      revert_pr_number: ${{ steps.set_outputs.outputs.revert_pr_number }}
      revert_branch: ${{ steps.set_outputs.outputs.revert_branch }}
      touches_workflows: ${{ steps.set_outputs.outputs.touches_workflows }}
      associated_pulls: ${{ steps.set_outputs.outputs.associated_pulls }}
    steps:
      - name: "Debug: event & push"
        run: |
          echo "PUSH SHA: $GITHUB_SHA"
          echo "Repository: $REPO"
          echo "Event path: $GITHUB_EVENT_PATH"
          echo "Event type: $GITHUB_EVENT_NAME"
          echo "Ref: $GITHUB_REF"
          echo "Commits:"
          jq -r '.commits[]? | "\(.id) \(.message)"' "$GITHUB_EVENT_PATH" || true
          jq '.head_commit' "$GITHUB_EVENT_PATH" || true

      - name: Get list of files changed in push
        id: detect_files
        run: |
          set -euo pipefail
          # Collect changed files across all commits
          files=$(jq -r '.commits[]? | (.added[]?, .modified[]?, .removed[]?)' "$GITHUB_EVENT_PATH" 2>/dev/null | sort -u || true)
          echo "FILES<<EOF" >> $GITHUB_OUTPUT
          echo "$files" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          if echo "$files" | grep -q '^\.github/workflows/'; then
            echo "touches_workflows=true" >> $GITHUB_OUTPUT
          else
            echo "touches_workflows=false" >> $GITHUB_OUTPUT
          fi

      - name: Check whether commit(s) are associated with PR(s)
        id: check_pr
        run: |
          set -euo pipefail
          # We'll query the commit->pulls endpoint for each commit in the push payload.
          commits=$(jq -r '.commits | .[].id' "$GITHUB_EVENT_PATH")
          echo "Checking ${commits} for associated PRs"
          pulls_json="[]"
          count=0
          pull_ids=()
          pull_summaries=()
          for c in $commits; do
            resp=$(curl -s -H "Accept: application/vnd.github+json" \
              -H "Authorization: token ${{ github.token }}" \
              "${{ env.GITHUB_API }}/repos/${{ env.REPO }}/commits/${c}/pulls")
            # merge results
            if [ "$(echo "$resp" | jq 'length')" -gt 0 ]; then
              pulls_json=$(jq -s 'add' <(echo "$pulls_json") <(echo "$resp"))
            fi
          done

          # Deduplicate by number
          pulls_unique=$(echo "$pulls_json" | jq 'unique_by(.number)')
          count=$(echo "$pulls_unique" | jq 'length')
          echo "Found $count associated pull(s)."
          echo "$pulls_unique" > pulls.json

          # Build a compact list of numbers/titles to pass later
          numbers=$(jq -r '.[].number' pulls.json | sort -u | xargs || true)
          summaries=$(jq -r '.[] | "\(.number): \(.title) (merged_at=\(.merged_at) merged=\(.merged // false) merge_commit_sha=\(.merge_commit_sha))"' pulls.json | sort -u || true)

          echo "pulls_count=$count" >> $GITHUB_OUTPUT
          echo "pulls_raw<<EOF" >> $GITHUB_OUTPUT
          jq -c '.' pulls.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "pull_numbers=${numbers}" >> $GITHUB_OUTPUT
          echo "pull_summaries<<EOF" >> $GITHUB_OUTPUT
          echo "$summaries" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # NOTE: we no longer abort if the push is associated with a PR.
      # We treat PR-merged commits (merge/squash/rebase) the same as direct pushes:
      # create a revert PR, merge it, and re-apply commits as a new PR for review.

      - name: Prepare auth token (ADMIN_PAT preferred when workflows changed)
        id: auth
        run: |
          # Prefer ADMIN_PAT (repo+workflow scopes) when present; else fall back to GITHUB_TOKEN
          AUTH="${{ secrets.ADMIN_PAT }}"
          if [ -z "$AUTH" ]; then
            echo "ADMIN_PAT not present; falling back to github.token (may be insufficient to push workflow file changes)."
            AUTH="${{ github.token }}"
          else
            echo "Using ADMIN_PAT for repo operations."
          fi
          echo "auth_token=$AUTH" >> $GITHUB_OUTPUT

      - name: Create revert branch & PR (revert incoming push)
        if: ${{ always() }}
        id: revert
        env:
          AUTH_TOKEN: ${{ steps.auth.outputs.auth_token }}
          REPO: ${{ env.REPO }}
          GITHUB_API: ${{ env.GITHUB_API }}
        run: |
          set -euo pipefail

          # Find changed files again (safer than relying on job output interpolation)
          files=$(jq -r '.commits[]? | (.added[]?, .modified[]?, .removed[]?)' "$GITHUB_EVENT_PATH" 2>/dev/null | sort -u || true)

          # If workflows were touched but token lacks workflow scope, exit so human can set ADMIN_PAT
          if echo "$files" | grep -q '^\.github/workflows/'; then
            if [ -z "${{ secrets.ADMIN_PAT }}" ]; then
              echo "Direct push touched .github/workflows/. A PAT with workflow scope (ADMIN_PAT) is required for operations that modify workflow files."
              echo "should_run=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi

          # Load commits in reverse order (newest first) so git revert succeeds without conflicts
          commits=$(jq -r '.commits | reverse | .[].id' "$GITHUB_EVENT_PATH")
          if [ -z "$commits" ]; then
            echo "No commits found in event payload; nothing to revert."
            echo "should_run=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Detected push to main (direct or via PR). Will create a revert branch and open a PR."
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

          # checkout full repo history using git clone and token for auth
          SHORT_SHA=${GITHUB_SHA::7}
          BRANCH="revert/direct-push-${SHORT_SHA}"

          git clone --no-tags "https://x-access-token:${AUTH_TOKEN}@github.com/${REPO}.git" repo
          cd repo
          git fetch --all
          git checkout main

          git checkout -b "$BRANCH"

          for c in $commits; do
            echo "Reverting commit $c"
            # detect merge commit (multiple parents); note: git rev-list prints commit + parents
            parents=$(git rev-list --parents -n 1 "$c" | wc -w | tr -d ' ')
            if [ "$parents" -gt 2 ]; then
              echo "Commit $c is a merge commit; reverting with -m 1"
              git revert --no-edit -m 1 "$c"
            else
              git revert --no-edit "$c"
            fi
          done

          # push revert branch
          git push "https://x-access-token:${AUTH_TOKEN}@github.com/${REPO}.git" "HEAD:refs/heads/${BRANCH}"

          # Compose PR body including any associated PR info (if present)
          pull_numbers=$(echo "${{ steps.check_pr.outputs.pull_numbers }}" || true)
          pull_summaries=$(echo "${{ steps.check_pr.outputs.pull_summaries }}" || true)

          title="Revert direct push ${SHORT_SHA} to main"
          body="Automated revert PR: created because commits were pushed to main (directly or via PR) and must be re-applied through a reviewable PR.\n\nDirect push SHA: ${GITHUB_SHA}\n\n"
          if [ -n "$pull_numbers" ]; then
            body="${body}Associated pull(s): ${pull_numbers}\n\nDetails:\n${pull_summaries}\n\n"
          fi
          body="${body}Please review & merge to restore repository state."

          create_resp=$(curl -s -X POST -H "Authorization: token ${AUTH_TOKEN}" -H "Accept: application/vnd.github+json" \
            "${GITHUB_API}/repos/${REPO}/pulls" \
            -d "$(jq -n --arg t "$title" --arg b "$body" --arg h "$BRANCH" '{title:$t, head:$h, base:"main", body:$b}')")

          echo "create_resp:"
          echo "$create_resp" | jq .

          pr_number=$(echo "$create_resp" | jq -r '.number // empty')
          if [ -z "$pr_number" ]; then
            echo "Failed to create revert PR. Response:"
            echo "$create_resp"
            echo "should_run=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "revert_pr_number=$pr_number" >> $GITHUB_OUTPUT
          echo "revert_branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "should_run=true" >> $GITHUB_OUTPUT
          if echo "$files" | grep -q '^\.github/workflows/'; then
            echo "touches_workflows=true" >> $GITHUB_OUTPUT
          else
            echo "touches_workflows=false" >> $GITHUB_OUTPUT
          fi

      - name: Ensure stable job outputs (aggregator)
        id: set_outputs
        run: |
          # Default values
          should_run=false
          revert_pr_number=
          revert_branch=
          touches_workflows=false
          associated_pulls=

          # Read from potential step outputs
          if [ -n "${{ steps.revert.outputs.should_run || '' }}" ]; then
            should_run="${{ steps.revert.outputs.should_run }}"
          fi

          revert_pr_number="${{ steps.revert.outputs.revert_pr_number || '' }}"
          revert_branch="${{ steps.revert.outputs.revert_branch || '' }}"
          touches_workflows="${{ steps.revert.outputs.touches_workflows || steps.detect_files.outputs.touches_workflows || 'false' }}"
          associated_pulls="${{ steps.check_pr.outputs.pull_numbers || '' }}"

          echo "should_run=$should_run" >> $GITHUB_OUTPUT
          echo "revert_pr_number=$revert_pr_number" >> $GITHUB_OUTPUT
          echo "revert_branch=$revert_branch" >> $GITHUB_OUTPUT
          echo "touches_workflows=$touches_workflows" >> $GITHUB_OUTPUT
          echo "associated_pulls=$associated_pulls" >> $GITHUB_OUTPUT

  approve-and-reapply:
    needs: detect-and-revert
    if: ${{ needs.detect-and-revert.outputs.should_run == 'true' }}
    runs-on: ubuntu-latest
    env:
      REPO: ${{ github.repository }}
      GITHUB_API: https://api.github.com
      AUTH_TOKEN: ${{ secrets.ADMIN_PAT || github.token }}
      REVERT_PR_NUMBER: ${{ needs.detect-and-revert.outputs.revert_pr_number }}
      REVERT_BRANCH: ${{ needs.detect-and-revert.outputs.revert_branch }}
      TOUCHES_WORKFLOWS: ${{ needs.detect-and-revert.outputs.touches_workflows }}
    steps:
      - name: Merge revert PR
        run: |
          set -euo pipefail
          if [ -z "${REVERT_PR_NUMBER}" ]; then
            echo "Missing revert PR number."
            exit 1
          fi

          # Attempt to merge the revert PR (this will fail if branch protections require reviews)
          payload=$(jq -n --arg method "${{ vars.REVERT_MERGE_METHOD || 'merge' }}" '{merge_method:$method}')
          resp=$(curl -s -X PUT -H "Authorization: token ${AUTH_TOKEN}" -H "Accept: application/vnd.github+json" \
            "${GITHUB_API}/repos/${REPO}/pulls/${REVERT_PR_NUMBER}/merge" \
            -d "$payload")

          merged=$(echo "$resp" | jq -r '.merged // false')
          if [ "$merged" != "true" ]; then
            echo "Automatic merge of revert PR failed or requires human approval. Response:"
            echo "$resp" | jq .
            echo "Please have a maintainer approve & merge PR #${REVERT_PR_NUMBER} (branch: ${REVERT_BRANCH})."
            # Exit non-zero so workflow shows a failure requiring human intervention
            exit 1
          fi

      - name: Reapply commits as a PR (cherry-pick original commits into a PR)
        run: |
          set -euo pipefail

          if [ "${TOUCHES_WORKFLOWS}" = "true" ] && [ -z "${{ secrets.ADMIN_PAT }}" ]; then
            echo "Reapply would touch .github/workflows/. Set ADMIN_PAT with repo+workflow scopes."
            exit 1
          fi

          commits=$(jq -r '.commits | .[].id' "$GITHUB_EVENT_PATH")
          if [ -z "${commits}" ]; then
            echo "No commits found in event payload; nothing to reapply."
            exit 0
          fi

          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

          SHORT_SHA=${GITHUB_SHA::7}
          BRANCH="reapply/direct-push-${SHORT_SHA}"

          git clone --no-tags "https://x-access-token:${AUTH_TOKEN}@github.com/${REPO}.git" repo
          cd repo
          git fetch --all
          git checkout main
          git pull --ff-only

          git checkout -b "$BRANCH"

          # cherry-pick commits in original order (oldest -> newest)
          for c in $commits; do
            echo "Cherry-picking commit $c"
            parents=$(git rev-list --parents -n 1 "$c" | wc -w | tr -d ' ')
            if [ "$parents" -gt 2 ]; then
              echo "Commit $c is a merge commit; cherry-picking with -m 1"
              git cherry-pick -m 1 "$c"
            else
              git cherry-pick "$c"
            fi
          done

          git push "https://x-access-token:${AUTH_TOKEN}@github.com/${REPO}.git" "HEAD:refs/heads/${BRANCH}"

          title="Apply direct push ${SHORT_SHA} via PR"
          body="This PR re-applies commits that were pushed to main (directly or via PR). It was created automatically after the revert PR was merged.\n\nOriginal push SHA: ${GITHUB_SHA}"

          create_resp=$(curl -s -X POST -H "Authorization: token ${AUTH_TOKEN}" -H "Accept: application/vnd.github+json" \
            "${GITHUB_API}/repos/${REPO}/pulls" \
            -d "$(jq -n --arg t "$title" --arg b "$body" --arg h "$BRANCH" '{title:$t, head:$h, base:"main", body:$b}')")

          echo "$create_resp" | jq .
          pr_number=$(echo "$create_resp" | jq -r '.number // empty')
          if [ -z "$pr_number" ]; then
            echo "Failed to create reapply PR. Response:"
            echo "$create_resp"
            exit 1
          fi
          echo "Reapply PR created: #${pr_number}"
